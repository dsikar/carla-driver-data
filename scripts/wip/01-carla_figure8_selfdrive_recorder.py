# -*- coding: utf-8 -*-
"""carla_figure8_selfdrive_recorder.ipynb

Automatically generated by Colab and modified to include camera recording with feedback and logging.

Original file is located at
    https://colab.research.google.com/drive/1yeDsDbYDUQLTtHdhqeZm-LFe50kVPBS7

# Figure of 8 to be followed with camera recording and data logging
"""

import carla
import math
import random
import time
# import carla_helpers as helpers
import os
import cv2
import numpy as np
from datetime import datetime

# Connect to the client and get the world object
client = carla.Client('localhost', 2000)
world = client.get_world()

# Load Town04 map
world = client.load_world('Town04')

"""## Helper functions"""

def get_figure8_waypoints(world):
    road_sequence = [42, 267, 43, 35, 861, 36, 760, 37, 1602, 38, 1091, 39, 1184, 40, 1401, 
                     41, 6, 45, 145, 46, 1072, 47, 774, 48, 901, 49, 1173, 50]
    carla_map = world.get_map()
    waypoints = carla_map.generate_waypoints(1.0)

    all_waypoints = []
    for road_id in road_sequence:
        road_waypoints = [wp for wp in waypoints if wp.road_id == road_id and wp.lane_id == -3]
        road_waypoints.sort(key=lambda x: x.s)
        all_waypoints.extend(road_waypoints)

    return all_waypoints

def set_spectator_camera_following_car(world, vehicle):
    spectator = world.get_spectator()
    vehicle_transform = vehicle.get_transform()
    forward_vector = vehicle_transform.get_forward_vector()
    offset_location = vehicle_transform.location + carla.Location(
        x=-5 * forward_vector.x,
        y=-5 * forward_vector.y,
        z=3
    )
    spectator.set_transform(carla.Transform(
        offset_location,
        carla.Rotation(pitch=-15, yaw=vehicle_transform.rotation.yaw, roll=0)
    ))
    return spectator

def compute_control(vehicle, target_wp, target_speed=10):
    control = carla.VehicleControl()
    current_transform = vehicle.get_transform()
    current_velocity = vehicle.get_velocity()
    speed = 3.6 * math.sqrt(current_velocity.x**2 + current_velocity.y**2)

    forward = current_transform.get_forward_vector()
    target_vector = target_wp.transform.location - current_transform.location
    forward_dot = forward.x * target_vector.x + forward.y * target_vector.y
    right_dot = -forward.y * target_vector.x + forward.x * target_vector.y
    steering = math.atan2(right_dot, forward_dot) / math.pi
    control.steer = max(-1.0, min(1.0, steering))

    speed_error = target_speed - speed
    if speed_error > 0:
        control.throttle = min(0.3, speed_error / target_speed)
        control.brake = 0.0
    else:
        control.throttle = 0.0
        control.brake = min(0.3, -speed_error / target_speed)

    return control

def setup_camera(world, vehicle, image_width=640, image_height=480, fov=90):
    """Setup an RGB camera attached to the vehicle with configurable parameters."""
    camera_bp = world.get_blueprint_library().find('sensor.camera.rgb')
    camera_bp.set_attribute('image_size_x', str(image_width))
    camera_bp.set_attribute('image_size_y', str(image_height))
    camera_bp.set_attribute('fov', str(fov))

    camera_transform = carla.Transform(carla.Location(x=1.5, y=0.0, z=1.8),
                                     carla.Rotation(pitch=-5.0, yaw=0.0, roll=0.0))
    camera = world.spawn_actor(camera_bp, camera_transform, attach_to=vehicle)
    return camera, camera_transform, image_width, image_height, fov

def process_image(image, output_dir, steering_angle, image_counter=[0]):
    """Process and save the captured image with steering data, with feedback."""
    array = np.frombuffer(image.raw_data, dtype=np.uint8)
    array = np.reshape(array, (image.height, image.width, 4))
    array = array[:, :, :3]

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
    image_filename = f"{timestamp}_steering_{steering_angle:.4f}.jpg"
    cv2.imwrite(os.path.join(output_dir, image_filename), array)

    image_counter[0] += 1
    if image_counter[0] % 100 == 0:
        print(f"Recorded {image_counter[0]} images at {datetime.now().strftime('%H:%M:%S')}")

    return image_counter[0]

def drive_figure_eight(world, vehicle, waypoints, camera, image_width, image_height, fov, 
                      output_dir='carla_dataset', target_speed=10):
    """Drive the vehicle along the figure-8 track and record camera data."""
    os.makedirs(output_dir, exist_ok=True)
    image_counter = [0]
    start_time = datetime.now()
    camera.listen(lambda image: process_image(image, output_dir, vehicle.get_control().steer, image_counter))

    try:
        for i, wp in enumerate(waypoints):
            print(f"Current target waypoint {i + 1}/{len(waypoints)}: {wp.transform.location}")
            world.debug.draw_point(
                wp.transform.location,
                size=0.2,
                color=carla.Color(255, 0, 0),
                life_time=5.0
            )

            while True:
                control = compute_control(vehicle, wp, target_speed)
                vehicle.apply_control(control)
                set_spectator_camera_following_car(world, vehicle)

                current_location = vehicle.get_transform().location
                distance_to_waypoint = current_location.distance(wp.transform.location)
                if distance_to_waypoint < 2.0:
                    break

                if world.get_settings().synchronous_mode:
                    world.tick()
                else:
                    time.sleep(0.1)

    except KeyboardInterrupt:
        print("Simulation interrupted by user.")
        control = carla.VehicleControl(throttle=0, brake=1)
        vehicle.apply_control(control)
    finally:
        end_time = datetime.now()
        camera.stop()
        with open(os.path.join(output_dir, 'log.txt'), 'w') as f:
            f.write(f"Simulation Log\n")
            f.write(f"Start Time: {start_time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"End Time: {end_time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Total Images Recorded: {image_counter[0]}\n")
            f.write(f"Camera Position: x={1.5}, y={0.0}, z={1.8}\n")
            f.write(f"Camera Rotation: pitch={-5.0}, yaw={0.0}, roll={0.0}\n")
            f.write(f"Camera Parameters: resolution={image_width}x{image_height}, fov={fov}\n")
        print(f"Simulation ended. Recorded {image_counter[0]} images. Log saved to {output_dir}/log.txt")

def draw_permanent_waypoint_lines(world, waypoints, color=carla.Color(0, 255, 0), thickness=0.02):
    for i in range(len(waypoints) - 1):
        wp1 = waypoints[i]
        wp2 = waypoints[i + 1]
        world.debug.draw_line(
            wp1.transform.location,
            wp2.transform.location,
            thickness=thickness,
            color=color,
            life_time=0
        )

"""## Main execution"""

def main(image_width=640, image_height=480, fov=90):
    client = carla.Client("localhost", 2000)
    client.set_timeout(10.0)
    world = client.get_world()

    settings = world.get_settings()
    settings.synchronous_mode = True
    settings.fixed_delta_seconds = 0.05
    world.apply_settings(settings)

    try:
        waypoints = get_figure8_waypoints(world)
        print(f"Number of waypoints retrieved: {len(waypoints)}")

        blueprint_library = world.get_blueprint_library()
        vehicle_bp = blueprint_library.filter("vehicle.tesla.model3")[0]
        spawn_point = waypoints[0].transform
        spawn_point.location.z += 2.0
        vehicle = world.spawn_actor(vehicle_bp, spawn_point)
        print(f"Vehicle spawned at {spawn_point.location}")

        camera, camera_transform, image_width, image_height, fov = setup_camera(world, vehicle, 
                                                                              image_width, image_height, fov)
        drive_figure_eight(world, vehicle, waypoints, camera, image_width, image_height, fov, output_dir="carla_dataset", target_speed=10)

    except Exception as e:
        print(f"Error: {e}")
    finally:
        if 'camera' in locals():
            camera.destroy()
            print("Camera destroyed.")
        if 'vehicle' in locals():
            vehicle.destroy()
            print("Vehicle destroyed.")
        settings.synchronous_mode = False
        world.apply_settings(settings)

if __name__ == "__main__":
    main()  # Default: 640x480, FOV 90
    # Example with different parameters: main(image_width=1920, image_height=1080, fov=120)