# -*- coding: utf-8 -*-
"""23-camera-placement-study.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xphZ5FDWl1TqKgQn5GJLToD-CyKADgrz

# Camera placement study

## Place vehicle
"""

import carla
import math
import random
import time
import carla_helpers as helpers
import time

# Connect to the client and get the world object
client = carla.Client('localhost', 2000)
world = client.get_world()

# load Town04 map
world = client.load_world('Town04')

# Get the blueprint library and the spawn points for the map
bp_lib = world.get_blueprint_library()

# Get the blueprint for the bycicle you want
vehicle_bp = bp_lib.find('vehicle.tesla.model3')

waypoints = helpers.get_town04_figure8_waypoints(world)
waypoint_0 = waypoints[0].transform
print(waypoint_0.location)
waypoint_0.location.z += 0.6
print(waypoint_0.location)

# Place observer where vehicle will be dropped
inside_vehicle = helpers.set_spectator_transform(world, waypoint_0.location, waypoint_0.rotation)
time.sleep(5)

# Spawn vehicle at start of figure of 8
vehicle = world.try_spawn_actor(vehicle_bp, waypoint_0)

"""## View functions"""

inside_vehicle = vehicle.get_transform()
base_transform = inside_vehicle
base_transform.location.z += 0.6
def side_view_left(world, base_transform):
    import carla_helpers as helpers
    x = base_transform.location.x + 0.1
    y = base_transform.location.y - 3.1
    z = base_transform.location.z
    yaw = base_transform.rotation.yaw + 90
    pitch = base_transform.rotation.pitch
    roll = base_transform.rotation.roll
    helpers.set_spectator_transform(world, (x,y,z),(pitch, yaw,roll))

# side_view_left(world, base_transform)

def side_view_left_close(world, base_transform):
    import carla_helpers as helpers
    x = base_transform.location.x + 0.1
    y = base_transform.location.y - 1.1
    z = base_transform.location.z + 0.78
    yaw = base_transform.rotation.yaw + 90
    pitch = base_transform.rotation.pitch
    roll = base_transform.rotation.roll
    helpers.set_spectator_transform(world, (x,y,z),(pitch, yaw,roll))

side_view_left_close(world, base_transform)

def side_view_left_top(world, base_transform):
    import carla_helpers as helpers
    x = base_transform.location.x + 0.1
    y = base_transform.location.y - 3.1
    z = base_transform.location.z + 2
    yaw = base_transform.rotation.yaw + 90
    pitch = base_transform.rotation.pitch - 27
    roll = base_transform.rotation.roll
    helpers.set_spectator_transform(world, (x,y,z),(pitch, yaw,roll))

# side_view_left_top(world, base_transform)

def side_view_right(world, base_transform):
    import carla_helpers as helpers
    x = base_transform.location.x + 0.1
    y = base_transform.location.y + 3.1
    z = base_transform.location.z
    yaw = base_transform.rotation.yaw - 90
    pitch = base_transform.rotation.pitch
    roll = base_transform.rotation.roll
    helpers.set_spectator_transform(world, (x,y,z),(pitch, yaw,roll))

# side_view_right(world, base_transform)

def side_view_right_top(world, base_transform):
    import carla_helpers as helpers
    x = base_transform.location.x + 0.1
    y = base_transform.location.y + 3.1
    z = base_transform.location.z + 2
    yaw = base_transform.rotation.yaw - 90
    pitch = base_transform.rotation.pitch - 27
    roll = base_transform.rotation.roll
    helpers.set_spectator_transform(world, (x,y,z),(pitch, yaw,roll))

# side_view_right_top(world, base_transform)

def side_view_left_top_front(world, base_transform):
    import carla_helpers as helpers
    x = base_transform.location.x + 1.8
    y = base_transform.location.y - 2.5
    z = base_transform.location.z + 1.5
    yaw = base_transform.rotation.yaw + 110
    pitch = base_transform.rotation.pitch - 27
    roll = base_transform.rotation.roll
    helpers.set_spectator_transform(world, (x,y,z),(pitch, yaw,roll))

#side_view_left_top_front(world, base_transform)

def side_view_right_top_front(world, base_transform):
    import carla_helpers as helpers
    x = base_transform.location.x + 1.8
    y = base_transform.location.y + 2.5
    z = base_transform.location.z + 1.5
    yaw = base_transform.rotation.yaw - 110
    pitch = base_transform.rotation.pitch - 27
    roll = base_transform.rotation.roll
    helpers.set_spectator_transform(world, (x,y,z),(pitch, yaw,roll))

# side_view_right_top_front(world, base_transform)

def front_view_top(world, base_transform):
    import carla_helpers as helpers
    x = base_transform.location.x + 3.5
    y = base_transform.location.y
    z = base_transform.location.z + 1.5
    yaw = base_transform.rotation.yaw - 180
    pitch = base_transform.rotation.pitch -33
    roll = base_transform.rotation.roll
    helpers.set_spectator_transform(world, (x,y,z),(pitch, yaw,roll))


#front_view_top(world, base_transform)

"""## Set View"""

base_transform = waypoints[0].transform
base_transform.location.z += 0.6
#side_view_left_top_front(world, base_transform)
front_view_top(world, base_transform)
#side_view_left(world, base_transform)
#side_view_left_top(world, base_transform)
side_view_left_top_front(world, base_transform)

"""## Camera Position Marker"""

base_transform = waypoints[0].transform
print(inside_vehicle.location)
print(base_transform.location)
base_transform.location.x += 1 # 0.35
#base_transform.location.y -= 2.1
base_transform.location.z = 1.8 #1.4
# yaw = base_transform.rotation.yaw + 90
# pitch = base_transform.rotation.pitch
# roll = base_transform.rotation.roll
helpers.place_waypoint_marker(world, base_transform, r=255, g=0, b=0, life_time=20.0)

"""## Camera Position
Based on marker
"""

x = base_transform.location.x + 0.35
y = base_transform.location.y
z = base_transform.location.z + 1.40
yaw = base_transform.rotation.yaw
pitch = base_transform.rotation.pitch -25
roll = base_transform.rotation.roll
camera_transform = helpers.set_spectator_transform(world, (x,y,z),(pitch, yaw,roll))

"""## Destroy Vehicle"""

helpers.list_all_vehicles(world)
helpers.destroy_vehicle(world, 145)

"""# Camera functions"""

import carla
import numpy as np
import queue
import time
import matplotlib.pyplot as plt

# Constants
CAMERA_WIDTH = 640  # Image width in pixels
CAMERA_HEIGHT = 360  # Image height in pixels
CAMERA_FOV = 90  # Field of view in degrees
CAMERA_LOCATION = camera_transform.location # carla.Location(x=1, y=0.0, z=1.5)  # Position relative to the vehicle
CAMERA_ROTATION = camera_transform.rotation # carla.Rotation(pitch=5.0, yaw=0.0, roll=0.0)  # Rotation relative to the vehicle

# def spawn_vehicle(world, spawn_point):
#     """
#     Spawn a vehicle at the first waypoint.

#     Parameters:
#     - world: CARLA world object.
#     - spawn_point: CARLA transform object for the spawn location.

#     Returns:
#     - vehicle: CARLA vehicle object.
#     """
#     # Get the blueprint for the vehicle
#     blueprint_library = world.get_blueprint_library()
#     vehicle_bp = blueprint_library.filter("vehicle.tesla.model3")[0]  # Choose a vehicle blueprint

#     # Spawn the vehicle at the first waypoint
#     #pawn_point = waypoints[0].transform
#     #spawn_point.location.z += 2.0  # Adjust spawn height to avoid collisions
#     vehicle = world.spawn_actor(vehicle_bp, spawn_point)
#     print(f"Vehicle spawned at {spawn_point.location}")
#     return vehicle

def attach_camera_to_vehicle(world, vehicle, camera_transform):
    """
    Attach a camera to the vehicle and set up the image capture.

    Parameters:
    - world: CARLA world object.
    - vehicle: CARLA vehicle object.

    Returns:
    - camera: CARLA camera object.
    - image_queue: Queue to store captured images.
    """
    # Get the blueprint for the camera
    blueprint_library = world.get_blueprint_library()
    camera_bp = blueprint_library.find("sensor.camera.rgb")
    camera_bp.set_attribute("image_size_x", str(CAMERA_WIDTH))
    camera_bp.set_attribute("image_size_y", str(CAMERA_HEIGHT))
    camera_bp.set_attribute("fov", str(CAMERA_FOV))

    # Attach the camera to the vehicle, alternative method, using the camera transform
    camera_transform = carla.Transform(CAMERA_LOCATION, CAMERA_ROTATION)
    camera = world.spawn_actor(camera_bp, camera_transform, attach_to=vehicle)
    print("Camera parameters FOV:{}, Image Size:({}, {})".format(CAMERA_FOV, CAMERA_WIDTH, CAMERA_HEIGHT))
    print(f"Camera attached to vehicle at {camera_transform.location}")
    print(f"Camera attached to vehicle at {camera_transform.rotation}")

    # Create a queue to store captured images
    image_queue = queue.Queue()

    # Set up the callback to store images in the queue
    camera.listen(image_queue.put)

    return camera, image_queue

def process_image(image):
    """
    Process the captured image and convert it to a numpy array.

    Parameters:
    - image: CARLA image object.

    Returns:
    - image_array: Numpy array representing the image.
    """
    # Convert the raw image data to a numpy array
    image_array = np.frombuffer(image.raw_data, dtype=np.uint8)
    image_array = image_array.reshape((CAMERA_HEIGHT, CAMERA_WIDTH, 4))  # RGBA format
    image_array = image_array[:, :, :3]  # Remove alpha channel (keep only RGB)
    return image_array

def plot_image(image_array):
    """
    Plot the captured image using matplotlib.

    Parameters:
    - image_array: Numpy array representing the image.
    """
    plt.imshow(image_array)
    plt.axis("off")  # Hide axes
    plt.show()

def test_vehicle_and_camera(world, vehicle, camera_transform):
    """
    Unit test to verify vehicle and camera instantiation, image size, and camera positioning.
    """
    # Connect to the CARLA server
    # Declared at top of script
    # client = carla.Client("localhost", 2000)
    # client.set_timeout(10.0)
    # world = client.get_world()

    # Enable synchronous mode
    settings = world.get_settings()
    settings.synchronous_mode = True
    settings.fixed_delta_seconds = 0.05
    world.apply_settings(settings)

    try:
        # Get waypoints for the figure-8 track
        # waypoints = get_figure8_waypoints(world)
        # print(f"Number of waypoints retrieved: {len(waypoints)}")

        # Spawn the vehicle
        #vehicle = spawn_vehicle(world, waypoints)

        # Attach the camera to the vehicle
        camera, image_queue = attach_camera_to_vehicle(world, vehicle, camera_transform)

        # Advance the simulation to allow the camera to capture an image
        for _ in range(10):  # Advance 10 frames
            world.tick()

        # Wait for the image to be captured
        start_time = time.time()
        while time.time() - start_time < 5.0:  # Wait up to 5 seconds
            if not image_queue.empty():
                image = image_queue.get()
                image_array = process_image(image)

                # Verify image size
                assert image_array.shape == (CAMERA_HEIGHT, CAMERA_WIDTH, 3), \
                    f"Image size mismatch: expected {(CAMERA_HEIGHT, CAMERA_WIDTH, 3)}, got {image_array.shape}"
                print("Image size verified successfully.")

                # Print camera position and rotation
                camera_transform = camera.get_transform()
                print(f"Camera position: {camera_transform.location}")
                print(f"Camera rotation: {camera_transform.rotation}")

                # Plot the captured image
                plot_image(image_array)
                break
            time.sleep(0.1)  # Small delay to avoid busy-waiting
        else:
            print("No image captured within the timeout period. Check camera setup.")
    finally:
        # Clean up
        if 'camera' in locals():
            camera.destroy()
            print("Camera destroyed.")
        #if 'vehicle' in locals():
        #    vehicle.destroy()
        #    print("Vehicle destroyed.")

# world declared at top of script
inside_vehicle = vehicle.get_transform()
test_vehicle_and_camera(world, vehicle, camera_transform)

"""# Camera functions - original"""

import carla
import numpy as np
import queue
import time
import matplotlib.pyplot as plt
import carla_helpers as helpers

base_transform = vehicle.get_transform()
# x = base_transform.location.x + 0.35
# y = base_transform.location.y
# z = base_transform.location.z + 1.40
# Values found by trial and error in previous cell
x = 1
y = 0
z = 1.80
yaw = base_transform.rotation.yaw
pitch = base_transform.rotation.pitch -25
roll = base_transform.rotation.roll

# Constants
CAMERA_WIDTH = 640  # Image width in pixels
CAMERA_HEIGHT = 360  # Image height in pixels
CAMERA_FOV = 90  # Field of view in degrees
CAMERA_POSITION = carla.Location(x, y, z)  # Position relative to the vehicle
CAMERA_ROTATION = carla.Rotation(pitch=5.0, yaw=0.0, roll=0.0)  # Rotation relative to the vehicle

def spawn_vehicle(world, waypoints):
    """
    Spawn a vehicle at the first waypoint.

    Parameters:
    - world: CARLA world object.
    - waypoints: List of waypoints for the figure-8 track.

    Returns:
    - vehicle: CARLA vehicle object.
    """
    # Get the blueprint for the vehicle
    blueprint_library = world.get_blueprint_library()
    vehicle_bp = blueprint_library.filter("vehicle.tesla.model3")[0]  # Choose a vehicle blueprint

    # Spawn the vehicle at the first waypoint
    spawn_point = waypoints[0].transform
    spawn_point.location.z += 0.1  # Adjust spawn height to avoid collisions
    vehicle = world.spawn_actor(vehicle_bp, spawn_point)
    print(f"Vehicle spawned at {spawn_point.location}")
    return vehicle

def attach_camera_to_vehicle(world, vehicle):
    """
    Attach a camera to the vehicle and set up the image capture.

    Parameters:
    - world: CARLA world object.
    - vehicle: CARLA vehicle object.

    Returns:
    - camera: CARLA camera object.
    - image_queue: Queue to store captured images.
    """
    # Get the blueprint for the camera
    blueprint_library = world.get_blueprint_library()
    camera_bp = blueprint_library.find("sensor.camera.rgb")
    camera_bp.set_attribute("image_size_x", str(CAMERA_WIDTH))
    camera_bp.set_attribute("image_size_y", str(CAMERA_HEIGHT))
    camera_bp.set_attribute("fov", str(CAMERA_FOV))

    # Attach the camera to the vehicle
    camera_transform = carla.Transform(CAMERA_POSITION, CAMERA_ROTATION)
    camera = world.spawn_actor(camera_bp, camera_transform, attach_to=vehicle)
    print(f"Camera attached to vehicle at {camera_transform.location}")

    # Create a queue to store captured images
    image_queue = queue.Queue()

    # Set up the callback to store images in the queue
    camera.listen(image_queue.put)

    return camera, image_queue

def process_image(image):
    """
    Process the captured image and convert it to a numpy array.

    Parameters:
    - image: CARLA image object.

    Returns:
    - image_array: Numpy array representing the image.
    """
    # Convert the raw image data to a numpy array
    image_array = np.frombuffer(image.raw_data, dtype=np.uint8)
    image_array = image_array.reshape((CAMERA_HEIGHT, CAMERA_WIDTH, 4))  # RGBA format
    image_array = image_array[:, :, :3]  # Remove alpha channel (keep only RGB)
    return image_array

def plot_image(image_array):
    """
    Plot the captured image using matplotlib.

    Parameters:
    - image_array: Numpy array representing the image.
    """
    plt.imshow(image_array)
    plt.axis("off")  # Hide axes
    plt.show()

def test_vehicle_and_camera(world):
    """
    Unit test to verify vehicle and camera instantiation, image size, and camera positioning.
    """
    # Connect to the CARLA server
    # Declared at top of script
    # client = carla.Client("localhost", 2000)
    # client.set_timeout(10.0)
    # world = client.get_world()

    # Enable synchronous mode
    settings = world.get_settings()
    settings.synchronous_mode = True
    settings.fixed_delta_seconds = 0.05
    world.apply_settings(settings)

    try:
        # Get waypoints for the figure-8 track
        waypoints = helpers.get_town04_figure8_waypoints(world)
        print(f"Number of waypoints retrieved: {len(waypoints)}")

        # Spawn the vehicle
        vehicle = spawn_vehicle(world, waypoints)
        time.sleep(5)
        # Attach the camera to the vehicle
        camera, image_queue = attach_camera_to_vehicle(world, vehicle)

        # Advance the simulation to allow the camera to capture an image
        for _ in range(10):  # Advance 10 frames
            world.tick()

        # Wait for the image to be captured
        start_time = time.time()
        while time.time() - start_time < 5.0:  # Wait up to 5 seconds
            if not image_queue.empty():
                image = image_queue.get()
                image_array = process_image(image)

                # Verify image size
                assert image_array.shape == (CAMERA_HEIGHT, CAMERA_WIDTH, 3), \
                    f"Image size mismatch: expected {(CAMERA_HEIGHT, CAMERA_WIDTH, 3)}, got {image_array.shape}"
                print("Image size verified successfully.")

                # Print camera position and rotation
                camera_transform = camera.get_transform()
                print("Camera parameters FOV:{}, Image Size:({}, {})".format(CAMERA_FOV, CAMERA_WIDTH, CAMERA_HEIGHT))
                print(f"Camera position: {camera_transform.location}")
                print(f"Camera rotation: {camera_transform.rotation}")
                # print(f"CAMERA_POSITION: {CAMERA_POSITION}")

                # Plot the captured image
                plot_image(image_array)
                break
            time.sleep(0.1)  # Small delay to avoid busy-waiting
        else:
            print("No image captured within the timeout period. Check camera setup.")
    finally:
        # Clean up
        if 'camera' in locals():
            camera.destroy()
            print("Camera destroyed.")
        if 'vehicle' in locals():
            vehicle.destroy()
            print("Vehicle destroyed.")

# world declared at top of script
test_vehicle_and_camera(world)

CAMERA_WIDTH = 1920  # Full HD resolution
CAMERA_HEIGHT = 1080
CAMERA_FOV = 90  # Medium FOV
CAMERA_FPS = 30  # Frame rate
# CAMERA_POSITION = carla.Location(x, y, z)  # Mounting position
# CAMERA_ROTATION = carla.Rotation(pitch, yaw, roll)  # Tilted downward
CAMERA_POSITION = carla.Location(x=1, y=0.0, z=1.4)  # Position relative to the vehicle
CAMERA_ROTATION = carla.Rotation(pitch=-5, yaw=0.0, roll=0.0)  # Rotation relative to the vehicle
test_vehicle_and_camera(world)

# x = base_transform.location.x + 0.35
# y = base_transform.location.y
# z = base_transform.location.z + 1.40
# yaw = base_transform.rotation.yaw
# pitch = base_transform.rotation.pitch -25
# roll = base_transform.rotation.roll
# Realistic camera parameters
CAMERA_WIDTH = 1920  # Full HD resolution
CAMERA_HEIGHT = 1080
CAMERA_FOV = 120  # Medium FOV
CAMERA_FPS = 30  # Frame rate
#CAMERA_POSITION = carla.Location(x, y, z)  # Mounting position
#CAMERA_ROTATION = carla.Rotation(pitch, yaw, roll)  # Tilted downward
CAMERA_POSITION = carla.Location(x=1.5, y=0.0, z=1.8)  # Position relative to the vehicle
CAMERA_ROTATION = carla.Rotation(pitch=-5.0, yaw=0.0, roll=0.0)  # Rotation relative to the vehicle
test_vehicle_and_camera(world)

# x = base_transform.location.x + 0.35
# y = base_transform.location.y
# z = base_transform.location.z + 1.40
# yaw = base_transform.rotation.yaw
# pitch = base_transform.rotation.pitch -25
# roll = base_transform.rotation.roll
# Realistic camera parameters
CAMERA_WIDTH = 1920  # Full HD resolution
CAMERA_HEIGHT = 1080
CAMERA_FOV = 120  # Medium FOV
CAMERA_FPS = 30  # Frame rate
#CAMERA_POSITION = carla.Location(x, y, z)  # Mounting position
#CAMERA_ROTATION = carla.Rotation(pitch, yaw, roll)  # Tilted downward
CAMERA_POSITION = carla.Location(x=1.5, y=0.0, z=1.8)  # Position relative to the vehicle
CAMERA_ROTATION = carla.Rotation(pitch=-5.0, yaw=-25, roll=0.0)  # Rotation relative to the vehicle
test_vehicle_and_camera(world)